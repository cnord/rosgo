// Code generated by ros-gen-go.
// source: BoundingBox.msg
// DO NOT EDIT!
package geographic_msgs

import (
	"io"

	"github.com/cnord/rosgo/ros"
)

type _MsgBoundingBox struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgBoundingBox) Text() string {
	return t.text
}

func (t *_MsgBoundingBox) Name() string {
	return t.name
}

func (t *_MsgBoundingBox) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgBoundingBox) NewMessage() ros.Message {
	m := new(BoundingBox)

	return m
}

var (
	MsgBoundingBox = &_MsgBoundingBox{
		`# Geographic map bounding box. 
#
# The two GeoPoints denote diagonally opposite corners of the box.
#
# If min_pt.latitude is NaN, the bounding box is "global", matching
# any valid latitude, longitude and altitude.
#
# If min_pt.altitude is NaN, the bounding box is two-dimensional and
# matches any altitude within the specified latitude and longitude
# range.

GeoPoint min_pt         # lowest and most Southwestern corner
GeoPoint max_pt         # highest and most Northeastern corner
`,
		"geographic_msgs/BoundingBox",
		"f62e8b5e390a3ac7603250d46e8f8446",
	}
)

type BoundingBox struct {
	MinPt GeoPoint
	MaxPt GeoPoint
}

func (m *BoundingBox) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "GeoPoint", &m.MinPt); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "GeoPoint", &m.MaxPt); err != nil {
		return err
	}

	return
}

func (m *BoundingBox) Deserialize(r io.Reader) (err error) {
	// MinPt
	if err = ros.DeserializeMessageField(r, "GeoPoint", &m.MinPt); err != nil {
		return err
	}

	// MaxPt
	if err = ros.DeserializeMessageField(r, "GeoPoint", &m.MaxPt); err != nil {
		return err
	}

	return
}
