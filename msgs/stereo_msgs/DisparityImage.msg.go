// Code generated by ros-gen-go.
// source: DisparityImage.msg
// DO NOT EDIT!
package stereo_msgs

import (
	"io"

	"github.com/cnord/rosgo/msgs/sensor_msgs"
	"github.com/cnord/rosgo/msgs/std_msgs"
	"github.com/cnord/rosgo/ros"
)

type _MsgDisparityImage struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgDisparityImage) Text() string {
	return t.text
}

func (t *_MsgDisparityImage) Name() string {
	return t.name
}

func (t *_MsgDisparityImage) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgDisparityImage) NewMessage() ros.Message {
	m := new(DisparityImage)

	return m
}

var (
	MsgDisparityImage = &_MsgDisparityImage{
		`# Separate header for compatibility with current TimeSynchronizer.
# Likely to be removed in a later release, use image.header instead.
Header header

# Floating point disparity image. The disparities are pre-adjusted for any
# x-offset between the principal points of the two cameras (in the case
# that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)
sensor_msgs/Image image

# Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
float32 f # Focal length, pixels
float32 T # Baseline, world units

# Subwindow of (potentially) valid disparity values.
sensor_msgs/RegionOfInterest valid_window

# The range of disparities searched.
# In the disparity image, any disparity less than min_disparity is invalid.
# The disparity search range defines the horopter, or 3D volume that the
# stereo algorithm can "see". Points with Z outside of:
#     Z_min = fT / max_disparity
#     Z_max = fT / min_disparity
# could not be found.
float32 min_disparity
float32 max_disparity

# Smallest allowed disparity increment. The smallest achievable depth range
# resolution is delta_Z = (Z^2/fT)*delta_d.
float32 delta_d
`,
		"stereo_msgs/DisparityImage",
		"04a177815f75271039fa21f16acad8c9",
	}
)

type DisparityImage struct {
	Header       std_msgs.Header
	Image        sensor_msgs.Image
	F            float32
	T            float32
	ValidWindow  sensor_msgs.RegionOfInterest
	MinDisparity float32
	MaxDisparity float32
	DeltaD       float32
}

func (m *DisparityImage) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "Header", &m.Header); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "sensor_msgs/Image", &m.Image); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.F); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.T); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "sensor_msgs/RegionOfInterest", &m.ValidWindow); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.MinDisparity); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.MaxDisparity); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.DeltaD); err != nil {
		return err
	}

	return
}

func (m *DisparityImage) Deserialize(r io.Reader) (err error) {
	// Header
	if err = ros.DeserializeMessageField(r, "Header", &m.Header); err != nil {
		return err
	}

	// Image
	if err = ros.DeserializeMessageField(r, "sensor_msgs/Image", &m.Image); err != nil {
		return err
	}

	// F
	if err = ros.DeserializeMessageField(r, "float32", &m.F); err != nil {
		return err
	}

	// T
	if err = ros.DeserializeMessageField(r, "float32", &m.T); err != nil {
		return err
	}

	// ValidWindow
	if err = ros.DeserializeMessageField(r, "sensor_msgs/RegionOfInterest", &m.ValidWindow); err != nil {
		return err
	}

	// MinDisparity
	if err = ros.DeserializeMessageField(r, "float32", &m.MinDisparity); err != nil {
		return err
	}

	// MaxDisparity
	if err = ros.DeserializeMessageField(r, "float32", &m.MaxDisparity); err != nil {
		return err
	}

	// DeltaD
	if err = ros.DeserializeMessageField(r, "float32", &m.DeltaD); err != nil {
		return err
	}

	return
}
