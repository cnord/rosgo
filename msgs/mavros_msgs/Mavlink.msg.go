// Code generated by ros-gen-go.
// source: Mavlink.msg
// DO NOT EDIT!
package mavros_msgs

import (
	"encoding/binary"
	"fmt"
	"io"

	"github.com/cnord/rosgo/msgs/std_msgs"
	"github.com/cnord/rosgo/ros"
)

const (
	Mavlink_FRAMING_OK            uint8 = 1
	Mavlink_FRAMING_BAD_CRC       uint8 = 2
	Mavlink_FRAMING_BAD_SIGNATURE uint8 = 3
	Mavlink_MAVLINK_V10           uint8 = 254
	Mavlink_MAVLINK_V20           uint8 = 253
)

type _MsgMavlink struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgMavlink) Text() string {
	return t.text
}

func (t *_MsgMavlink) Name() string {
	return t.name
}

func (t *_MsgMavlink) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgMavlink) NewMessage() ros.Message {
	m := new(Mavlink)

	return m
}

var (
	MsgMavlink = &_MsgMavlink{
		`# Mavlink message transport type.
#
# Used to transport mavlink_message_t via ROS topic
#
# :framing_status:
#       Frame decoding status: OK, CRC error, bad Signature (mavlink v2.0)
#       You may simply drop all non valid messages.
#       Used for GCS Bridge to transport unknown messages.
#
# :magic:
#       STX byte, used to determine protocol version v1.0 or v2.0.
#
# Please use mavros_msgs::mavlink::convert() from <mavros_msgs/mavlink_convert.h>
# to convert between ROS and MAVLink message type

# mavlink_framing_t enum
uint8 FRAMING_OK = 1
uint8 FRAMING_BAD_CRC = 2
uint8 FRAMING_BAD_SIGNATURE = 3

# stx values
uint8 MAVLINK_V10 = 254
uint8 MAVLINK_V20 = 253

std_msgs/Header header
uint8 framing_status

uint8 magic		# STX byte
uint8 len
uint8 incompat_flags
uint8 compat_flags
uint8 seq
uint8 sysid
uint8 compid
uint32 msgid		# 24-bit message id
uint16 checksum
uint64[] payload64
uint8[] signature	# optional signature
`,
		"mavros_msgs/Mavlink",
		"41093e1fd0f3eea1da2aa33a177e5ba6",
	}
)

type Mavlink struct {
	Header        std_msgs.Header
	FramingStatus uint8
	Magic         uint8
	Len           uint8
	IncompatFlags uint8
	CompatFlags   uint8
	Seq           uint8
	Sysid         uint8
	Compid        uint8
	Msgid         uint32
	Checksum      uint16
	Payload64     []uint64
	Signature     []uint8
}

func (m *Mavlink) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "std_msgs/Header", &m.Header); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.FramingStatus); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Magic); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Len); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.IncompatFlags); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.CompatFlags); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Seq); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Sysid); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Compid); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint32", &m.Msgid); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint16", &m.Checksum); err != nil {
		return err
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Payload64)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Payload64 {
		if err = ros.SerializeMessageField(w, "uint64", &elem); err != nil {
			return err
		}
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Signature)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Signature {
		if err = ros.SerializeMessageField(w, "uint8", &elem); err != nil {
			return err
		}
	}

	return
}

func (m *Mavlink) Deserialize(r io.Reader) (err error) {
	// Header
	if err = ros.DeserializeMessageField(r, "std_msgs/Header", &m.Header); err != nil {
		return err
	}

	// FramingStatus
	if err = ros.DeserializeMessageField(r, "uint8", &m.FramingStatus); err != nil {
		return err
	}

	// Magic
	if err = ros.DeserializeMessageField(r, "uint8", &m.Magic); err != nil {
		return err
	}

	// Len
	if err = ros.DeserializeMessageField(r, "uint8", &m.Len); err != nil {
		return err
	}

	// IncompatFlags
	if err = ros.DeserializeMessageField(r, "uint8", &m.IncompatFlags); err != nil {
		return err
	}

	// CompatFlags
	if err = ros.DeserializeMessageField(r, "uint8", &m.CompatFlags); err != nil {
		return err
	}

	// Seq
	if err = ros.DeserializeMessageField(r, "uint8", &m.Seq); err != nil {
		return err
	}

	// Sysid
	if err = ros.DeserializeMessageField(r, "uint8", &m.Sysid); err != nil {
		return err
	}

	// Compid
	if err = ros.DeserializeMessageField(r, "uint8", &m.Compid); err != nil {
		return err
	}

	// Msgid
	if err = ros.DeserializeMessageField(r, "uint32", &m.Msgid); err != nil {
		return err
	}

	// Checksum
	if err = ros.DeserializeMessageField(r, "uint16", &m.Checksum); err != nil {
		return err
	}

	// Payload64
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for Payload64: %s", err)
		}
		m.Payload64 = make([]uint64, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "uint64", &m.Payload64[i]); err != nil {
				return err
			}
		}
	}

	// Signature
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for Signature: %s", err)
		}
		m.Signature = make([]uint8, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "uint8", &m.Signature[i]); err != nil {
				return err
			}
		}
	}

	return
}
