// Code generated by ros-gen-go.
// source: FileOpen.srv
// DO NOT EDIT!
package mavros_msgs

import (
	"io"

	"github.com/cnord/rosgo/ros"
)

// Service type metadata
type _SrvFileOpen struct {
	name    string
	md5sum  string
	text    string
	reqType ros.MessageType
	resType ros.MessageType
}

func (t *_SrvFileOpen) Name() string                  { return t.name }
func (t *_SrvFileOpen) MD5Sum() string                { return t.md5sum }
func (t *_SrvFileOpen) Text() string                  { return t.text }
func (t *_SrvFileOpen) RequestType() ros.MessageType  { return t.reqType }
func (t *_SrvFileOpen) ResponseType() ros.MessageType { return t.resType }
func (t *_SrvFileOpen) NewService() ros.Service {
	return new(FileOpen)
}

var (
	SrvFileOpen = &_SrvFileOpen{
		"mavros_msgs/FileOpen",
		"99a3f49cc67b91477cf49ff15c42af0e",
		`# FTP::Open
#
# :file_path:	used as session id in read/write/close services
# :size:	file size returned for MODE_READ
# :success:	indicates success end of request
# :r_errno:	remote errno if applicapable

uint8 MODE_READ = 0	# open for read
uint8 MODE_WRITE = 1	# open for write
uint8 MODE_CREATE = 2	# do creat()

string file_path
uint8 mode
---
uint32 size
bool success
int32 r_errno
`,
		MsgFileOpenRequest,
		MsgFileOpenResponse,
	}
)

type FileOpen struct {
	Request  FileOpenRequest
	Response FileOpenResponse
}

func (s *FileOpen) ReqMessage() ros.Message { return &s.Request }
func (s *FileOpen) ResMessage() ros.Message { return &s.Response }

// FileOpenRequest

const (
	FileOpenRequest_MODE_READ   uint8 = 0
	FileOpenRequest_MODE_WRITE  uint8 = 1
	FileOpenRequest_MODE_CREATE uint8 = 2
)

type _MsgFileOpenRequest struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgFileOpenRequest) Text() string {
	return t.text
}

func (t *_MsgFileOpenRequest) Name() string {
	return t.name
}

func (t *_MsgFileOpenRequest) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgFileOpenRequest) NewMessage() ros.Message {
	m := new(FileOpenRequest)

	return m
}

var (
	MsgFileOpenRequest = &_MsgFileOpenRequest{
		`# FTP::Open
#
# :file_path:	used as session id in read/write/close services
# :size:	file size returned for MODE_READ
# :success:	indicates success end of request
# :r_errno:	remote errno if applicapable

uint8 MODE_READ = 0	# open for read
uint8 MODE_WRITE = 1	# open for write
uint8 MODE_CREATE = 2	# do creat()

string file_path
uint8 mode
`,
		"mavros_msgs/FileOpenRequest",
		"",
	}
)

type FileOpenRequest struct {
	FilePath string
	Mode     uint8
}

func (m *FileOpenRequest) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "string", &m.FilePath); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Mode); err != nil {
		return err
	}

	return
}

func (m *FileOpenRequest) Deserialize(r io.Reader) (err error) {
	// FilePath
	if err = ros.DeserializeMessageField(r, "string", &m.FilePath); err != nil {
		return err
	}

	// Mode
	if err = ros.DeserializeMessageField(r, "uint8", &m.Mode); err != nil {
		return err
	}

	return
}

// FileOpenResponse

type _MsgFileOpenResponse struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgFileOpenResponse) Text() string {
	return t.text
}

func (t *_MsgFileOpenResponse) Name() string {
	return t.name
}

func (t *_MsgFileOpenResponse) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgFileOpenResponse) NewMessage() ros.Message {
	m := new(FileOpenResponse)

	return m
}

var (
	MsgFileOpenResponse = &_MsgFileOpenResponse{
		`
uint32 size
bool success
int32 r_errno
`,
		"mavros_msgs/FileOpenResponse",
		"",
	}
)

type FileOpenResponse struct {
	Size    uint32
	Success bool
	RErrno  int32
}

func (m *FileOpenResponse) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "uint32", &m.Size); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "bool", &m.Success); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "int32", &m.RErrno); err != nil {
		return err
	}

	return
}

func (m *FileOpenResponse) Deserialize(r io.Reader) (err error) {
	// Size
	if err = ros.DeserializeMessageField(r, "uint32", &m.Size); err != nil {
		return err
	}

	// Success
	if err = ros.DeserializeMessageField(r, "bool", &m.Success); err != nil {
		return err
	}

	// RErrno
	if err = ros.DeserializeMessageField(r, "int32", &m.RErrno); err != nil {
		return err
	}

	return
}
