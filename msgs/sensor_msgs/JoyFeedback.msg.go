// Code generated by ros-gen-go.
// source: JoyFeedback.msg
// DO NOT EDIT!
package sensor_msgs

import (
	"io"

	"github.com/cnord/rosgo/ros"
)

const (
	JoyFeedback_TYPE_LED    uint8 = 0
	JoyFeedback_TYPE_RUMBLE uint8 = 1
	JoyFeedback_TYPE_BUZZER uint8 = 2
)

type _MsgJoyFeedback struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgJoyFeedback) Text() string {
	return t.text
}

func (t *_MsgJoyFeedback) Name() string {
	return t.name
}

func (t *_MsgJoyFeedback) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgJoyFeedback) NewMessage() ros.Message {
	m := new(JoyFeedback)

	return m
}

var (
	MsgJoyFeedback = &_MsgJoyFeedback{
		`# Declare of the type of feedback
uint8 TYPE_LED    = 0
uint8 TYPE_RUMBLE = 1
uint8 TYPE_BUZZER = 2

uint8 type

# This will hold an id number for each type of each feedback.
# Example, the first led would be id=0, the second would be id=1
uint8 id

# Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is
# actually binary, driver should treat 0<=x<0.5 as off, 0.5<=x<=1 as on.
float32 intensity

`,
		"sensor_msgs/JoyFeedback",
		"f4dcd73460360d98f36e55ee7f2e46f1",
	}
)

type JoyFeedback struct {
	Type      uint8
	Id        uint8
	Intensity float32
}

func (m *JoyFeedback) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "uint8", &m.Type); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.Id); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float32", &m.Intensity); err != nil {
		return err
	}

	return
}

func (m *JoyFeedback) Deserialize(r io.Reader) (err error) {
	// Type
	if err = ros.DeserializeMessageField(r, "uint8", &m.Type); err != nil {
		return err
	}

	// Id
	if err = ros.DeserializeMessageField(r, "uint8", &m.Id); err != nil {
		return err
	}

	// Intensity
	if err = ros.DeserializeMessageField(r, "float32", &m.Intensity); err != nil {
		return err
	}

	return
}
