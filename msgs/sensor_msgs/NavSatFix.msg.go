// Code generated by ros-gen-go.
// source: NavSatFix.msg
// DO NOT EDIT!
package sensor_msgs

import (
	"encoding/binary"
	"fmt"
	"io"

	"github.com/cnord/rosgo/msgs/std_msgs"
	"github.com/cnord/rosgo/ros"
)

const (
	COVARIANCE_TYPE_UNKNOWN        uint8 = 0
	COVARIANCE_TYPE_APPROXIMATED   uint8 = 1
	COVARIANCE_TYPE_DIAGONAL_KNOWN uint8 = 2
	COVARIANCE_TYPE_KNOWN          uint8 = 3
)

type _MsgNavSatFix struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgNavSatFix) Text() string {
	return t.text
}

func (t *_MsgNavSatFix) Name() string {
	return t.name
}

func (t *_MsgNavSatFix) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgNavSatFix) NewMessage() ros.Message {
	m := new(NavSatFix)

	return m
}

var (
	MsgNavSatFix = &_MsgNavSatFix{
		`# Navigation Satellite fix for any Global Navigation Satellite System
#
# Specified using the WGS 84 reference ellipsoid

# header.stamp specifies the ROS time for this measurement (the
#        corresponding satellite time may be reported using the
#        sensor_msgs/TimeReference message).
#
# header.frame_id is the frame of reference reported by the satellite
#        receiver, usually the location of the antenna.  This is a
#        Euclidean frame relative to the vehicle, not a reference
#        ellipsoid.
Header header

# satellite fix status information
NavSatStatus status

# Latitude [degrees]. Positive is north of equator; negative is south.
float64 latitude

# Longitude [degrees]. Positive is east of prime meridian; negative is west.
float64 longitude

# Altitude [m]. Positive is above the WGS 84 ellipsoid
# (quiet NaN if no altitude is available).
float64 altitude

# Position covariance [m^2] defined relative to a tangential plane
# through the reported position. The components are East, North, and
# Up (ENU), in row-major order.
#
# Beware: this coordinate system exhibits singularities at the poles.

float64[9] position_covariance

# If the covariance of the fix is known, fill it in completely. If the
# GPS receiver provides the variance of each measurement, put them
# along the diagonal. If only Dilution of Precision is available,
# estimate an approximate covariance from that.

uint8 COVARIANCE_TYPE_UNKNOWN = 0
uint8 COVARIANCE_TYPE_APPROXIMATED = 1
uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
uint8 COVARIANCE_TYPE_KNOWN = 3

uint8 position_covariance_type
`,
		"sensor_msgs/NavSatFix",
		"2d3a8cd499b9b4a0249fb98fd05cfa48",
	}
)

type NavSatFix struct {
	Header                 std_msgs.Header
	Status                 NavSatStatus
	Latitude               float64
	Longitude              float64
	Altitude               float64
	PositionCovariance     [9]float64
	PositionCovarianceType uint8
}

func (m *NavSatFix) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "Header", &m.Header); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "NavSatStatus", &m.Status); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float64", &m.Latitude); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float64", &m.Longitude); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "float64", &m.Altitude); err != nil {
		return err
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.PositionCovariance)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.PositionCovariance {
		if err = ros.SerializeMessageField(w, "float64", &elem); err != nil {
			return err
		}
	}

	if err = ros.SerializeMessageField(w, "uint8", &m.PositionCovarianceType); err != nil {
		return err
	}

	return
}

func (m *NavSatFix) Deserialize(r io.Reader) (err error) {
	// Header
	if err = ros.DeserializeMessageField(r, "Header", &m.Header); err != nil {
		return err
	}

	// Status
	if err = ros.DeserializeMessageField(r, "NavSatStatus", &m.Status); err != nil {
		return err
	}

	// Latitude
	if err = ros.DeserializeMessageField(r, "float64", &m.Latitude); err != nil {
		return err
	}

	// Longitude
	if err = ros.DeserializeMessageField(r, "float64", &m.Longitude); err != nil {
		return err
	}

	// Altitude
	if err = ros.DeserializeMessageField(r, "float64", &m.Altitude); err != nil {
		return err
	}

	// PositionCovariance
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for PositionCovariance: %s", err)
		}
		if size > 9 {
			return fmt.Errorf("array size for PositionCovariance too large: expected=9, got=%d", size)
		}
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "float64", &m.PositionCovariance[i]); err != nil {
				return err
			}
		}
	}

	// PositionCovarianceType
	if err = ros.DeserializeMessageField(r, "uint8", &m.PositionCovarianceType); err != nil {
		return err
	}

	return
}
